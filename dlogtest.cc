/*
 * Command line program to test the dlog library.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <gmp.h>

#include <sys/time.h>
#include <time.h>

#include "include/types.h"
#include "include/dlog.h"
#include "include/randomhelpers.h"

typedef enum { PH, RHO } Algorithm;

bool test_random_prime_order (mpz_t result, mpz_t alpha, mpz_t p, mpz_t n, mpz_t beta,
                              mpz_t y, unsigned int nBits, unsigned int pBits,
                              gmp_randstate_t rstate, bool verbose, Algorithm alg);

                     
void usage () {
    printf ("Usage: dlogtest [-h] [-l|-r] [-t] [-c count [-n nBits] [-p pBits] [-s sBits]] [-v] [alpha p n beta]\n");
}

void help () {
    usage ();
    printf ("Options:\n"
            "  -h\t display this help message and exit\n"
            "  -v\t verbose, display more information\n"
            " Algorithm selection:\n"
            "  -r\t use the Pollard-Rho algorithm (default)\n"
            "  -l\t use the Pohlig-Hellman algorithm\n"
            " Test cases:\n"
            "  -t\t test the algorithm with specific discrete log instances\n"
            " Random testing:\n"
            "  -cN\t run the algorithm N times on random discrete log instances\n"
            "  -p\t prime which determines the group Z_p^* of random instances (default 32)\n"
            "  -n\t number of bits in the subgroup size of random instances (default 16)\n"
            "  -s\t make n sBits-smooth (default 0)\n"
            " Extra arguments:\n"
            "  If all of alpha, p, n, and beta are specified, compute log_{alpha}(beta) in\n"
            "  the subgroup of order n of Z_p^* generated by alpha. If n is not the correct order,"
            "  then the algorithm will likely fail.\n"
            );
}

bool test_alg (mpz_t result, mpz_t alpha, mpz_t p, mpz_t n, mpz_t beta,
               gmp_randstate_t rstate, bool verbose, Algorithm alg) {

    bool success = true;
    int runCount = 1;

    if (alg == RHO) {
        runCount = pollard_rho (result, alpha, p, n, beta, rstate);
    } else {
        CFactoredInteger fi;
        fi.factorValue (n);
        if (fi.hasMallocError ()) {
            fputs ("Malloc error in CFactoredInteger.factorValue\n", stderr);
            return false;
        }
        pohlig_hellman (result, alpha, p, &fi, beta, rstate);
    }

    mpz_t beta2;
    mpz_init (beta2);
    mpz_powm (beta2, alpha, result, p);
    if (mpz_cmp (beta, beta2) != 0) {
        success =  false;
    }
    mpz_clear (beta2);

    if (verbose) {
        if (success) { printf ("[ok] "); }
        else { printf ("[FAIL!] "); }

        gmp_printf ("log base %Zd of %Zd, in Z_{%Zd}, with n = %Zd\n",
                    alpha, beta, p, n);

        gmp_printf ("\trunCount = %d; result = %Zd\n", runCount, result);
    }

    return success;
}

bool test_random_order (mpz_t result, mpz_t alpha, mpz_t p, mpz_t n, mpz_t beta,
                        mpz_t y, unsigned int nBits, unsigned int pBits, unsigned int sBits,
                        gmp_randstate_t rstate, bool verbose, Algorithm alg, PH_ARG_LIST) {

    if (alg == RHO) {
        return test_random_prime_order (result, alpha, p, n, beta, y, nBits, pBits,
                                        rstate, verbose, alg);
    }

    CFactoredInteger fi;

    // pick n and y such that p = n * y + 1 is prime.
    do {

        if (sBits > 0) {
            fi.randomSmoothExactBits (nBits, rstate, sBits);
        } else {
            fi.random (nBits, rstate);
        }

        mpz_set (n, fi.value);

        // pick random even integer so the product n * y is at most pBits bits
        mpz_urandomb (y, rstate, pBits - nBits - 2);

        mpz_setbit (y, pBits - nBits - 2);
        mpz_mul_ui (y, y, 2);

        //gmp_printf ("n = %Zd\n", n);
        //gmp_printf ("        y = %Zd\n", y);

        mpz_mul (p, y, n);
        mpz_add_ui (p, p, 1);

    } while (!mpz_probab_prime_p (p, 10));

    mpz_t pMinus1;
    mpz_init (pMinus1);
    mpz_sub_ui (pMinus1, p, 1);
    
    //printf ("generated random prime with specified base order length\n");
    //gmp_printf ("prime = %Zd\n", p);
    //gmp_printf ("prime bits = %u\n", mpz_sizeinbase (p, 2));

    // find an element alpha of order n
    mpz_t gamma, delta, e;
    mpz_init (gamma); mpz_init (delta); mpz_init (e);
    mpz_set_ui (alpha, 1);
    for (unsigned int i = 0; i < fi.nFactors; i++) {
        //gmp_printf ("[%d] (%Zd)^(%lu):\n", i, fi.factors[i].prime, fi.factors[i].power);
        mpz_div (e, n, fi.factors[i].prime);
        do {
            mpz_urandomm (gamma, rstate, pMinus1);
            mpz_add_ui (gamma, gamma, 1); // 1 <= gamma <= p-1
            mpz_powm (gamma, gamma, y, p); // random element in subgroup
                                           // of order n

            mpz_powm (delta, gamma, e, p);
        } while (mpz_cmp_ui (delta, 1) == 0);

        //gmp_printf ("\tgamma = %Zd\n", gamma);

        // delta = q^c = value of current prime power
        mpz_pow_ui (delta, fi.factors[i].prime, fi.factors[i].power);

        // e = n/q^c = product of other prime powers
        mpz_div (e, n, delta);

        // delta = gamma^(n/q^c), where gamma^(n/q) != 1
        mpz_powm (delta, gamma, e, p);

        mpz_mul (alpha, alpha, delta);
        mpz_mod (alpha, alpha, p);
        
    }

    // Try to find a smaller element
    /*unsigned int m = 20;
    mpz_t (alpha2);
    mpz_init (alpha2);

    mpz_invert (alpha2, alpha, p);
    if (verbose) {
        gmp_printf ("alpha bits: %zu\n", mpz_sizeinbase (alpha, 2));
        gmp_printf ("alpha^(-1) bits: %zu\n", mpz_sizeinbase (alpha2, 2));
    }

    if (mpz_cmp (alpha2, alpha) < 0) {
        mpz_set (alpha, alpha2);
    }

    //mpz_sub_ui (n, n, 2);

    while (m > 0) {
        mpz_urandomm (e, rstate, n);
        //mpz_add_ui (e, e, 2);
        mpz_gcd (delta, e, n);
        if (mpz_cmp_ui (delta, 1) == 0) {
            mpz_powm (alpha2, alpha, e, p);
            if (mpz_cmp (alpha2, alpha) < 0) {
                mpz_set (alpha, alpha2);
            }
            m--;
        }
    }
    if (verbose)
        gmp_printf ("alpha' bits: %zu\n", mpz_sizeinbase (alpha, 2));

    //mpz_add_ui (n, n, 2);

    mpz_clear (alpha2);
    */
    mpz_clear (gamma); mpz_clear (delta); mpz_clear (e); mpz_clear (pMinus1);

    mpz_sub_ui (n, n, 1);
    mpz_urandomm (y, rstate, n);
    mpz_add_ui (y, y, 1);
    mpz_add_ui (n, n, 1);

    mpz_powm (beta, alpha, y, p);

    timeval start, end;
    gettimeofday (&start, NULL);
   
    //gmp_printf ("About to call PH: log base %Zd of %Zd, in Z_{%Zd}, with n = %Zd\n",
    //                alpha, beta, p, n);

    pohlig_hellman (result, alpha, p, &fi, beta, rstate, LIST_PH_LOCALS);

    gettimeofday (&end, NULL);

    long diff;
    if (end.tv_sec > start.tv_sec) {
        diff = pow(10, 6) - start.tv_usec + end.tv_usec;
    } else {
        diff = end.tv_usec - start.tv_usec;
    }

    bool success = true;
    if (mpz_cmp (result, y) != 0)
        success = false;

    if (verbose) {
        if (success) { printf ("[ok] "); }
        else { printf ("[FAIL!] "); }

        gmp_printf ("log base %Zd of %Zd, in Z_{%Zd}, with n = %Zd\n",
                    alpha, beta, p, n);

        gmp_printf ("\texpected = %Zd; result = %Zd\n",
                                     y, result);
        ldiv_t sec = ldiv (diff, 1000000);
        ldiv_t msec = ldiv (sec.rem, 1000);
        printf ("\trun time: %lds %ldms %ldus (%ld tot usec)\n", sec.quot, msec.quot, msec.rem, diff);
        //printf ("\trun time: %ld usec\n", diff);
    }

    return success;
}

bool test_random_prime_order (mpz_t result, mpz_t alpha, mpz_t p, mpz_t n, mpz_t beta,
                              mpz_t y, unsigned int nBits, unsigned int pBits,
                              gmp_randstate_t rstate, bool verbose, Algorithm alg) {

    // pick prime n and y such that p = n * y + 1 is prime.
    do {

        do {
            mpz_urandomb (n, rstate, nBits - 1);
            mpz_setbit (n, nBits - 1);
            mpz_nextprime (n, n);
        } while (mpz_sizeinbase (n, 2) > nBits);

        // pick random even integer so the product n * y is at most pBits bits
        mpz_urandomb (y, rstate, pBits - nBits - 2);
        mpz_setbit (y, pBits - nBits - 2);
        mpz_mul_ui (y, y, 2);

        //gmp_printf ("n = %Zd\n", n);
        //gmp_printf ("        y = %Zd\n", y);

        mpz_mul (p, y, n);
        mpz_add_ui (p, p, 1);

    } while (!mpz_probab_prime_p (p, 10));
    
    //printf ("generated random prime with specified base order length\n");
    //gmp_printf ("prime = %Zd\n", p);
    //gmp_printf ("prime bits = %u\n", mpz_sizeinbase (p, 2));

    // find an element of order n
    do {
        mpz_urandomm (alpha, rstate, p);
        mpz_powm (alpha, alpha, y, p);
    } while (mpz_cmp_ui (alpha, 1) == 0);

    mpz_urandomm (y, rstate, n);
    mpz_powm (beta, alpha, y, p);

    int runCount = 1;
    
    if (alg == RHO) {
        runCount = pollard_rho (result, alpha, p, n, beta, rstate);
    } else {
        CFactoredInteger fi;
        fi.factorValue (n);
        if (fi.hasMallocError ()) {
            fputs ("Malloc error in CFactoredInteger.factorValue\n", stderr);
            return false;
        }
        pohlig_hellman (result, alpha, p, &fi, beta, rstate);
    }

    if (verbose && runCount > 1) {
        gmp_printf ("Run Count (%d) > 1 : %Zd, %Zd, %Zd, %Zd; %Zd\n", runCount,
                    alpha, p, n, beta, result);
    }

    bool success = true;
    if (mpz_cmp (result, y) != 0)
        success = false;

    if (verbose) {
        if (success) { printf ("[ok] "); }
        else { printf ("[FAIL!] "); }

        gmp_printf ("log base %Zd of %Zd, in Z_{%Zd}, with n = %Zd\n",
                    alpha, beta, p, n);

        gmp_printf ("\texpected = %Zd; result = %Zd\n",
                                     y, result);
    }

    return success;

}

int main (int argc, char **argv) {
    mpz_t result, alpha, p, n, beta, y;
    mpz_init (result);
    mpz_init (alpha); mpz_init (p); mpz_init (n); mpz_init (beta);
    mpz_init (y);

    gmp_randstate_t rstate;

    int returnValue = EXIT_SUCCESS;

    bool verbose = false;
    bool test = false;
    Algorithm alg = RHO;
    
    int count = 0;
    unsigned int nBits = 16;
    unsigned int pBits = 32;
    unsigned int sBits = 0;

    char *endptr;
    int opt;
    while ((opt = getopt (argc, argv, "hlrc:vtn:p:s:")) != -1) {
        switch (opt) {
        case 'h':
            help ();
            exit (EXIT_SUCCESS);
            break;
        case 'v':
            verbose = true;
            break;
        case 't':
            test = true;
            break;
        case 'c':
            count = strtoul (optarg, &endptr, 10);
            if (*endptr != '\0') {
                usage ();
                exit (1);
            }
            break;
        case 'n':
            nBits = strtoul (optarg, &endptr, 10);
            if (*endptr != '\0') {
                usage ();
                exit (1);
            }
            break;
        case 'p':
            pBits = strtoul (optarg, &endptr, 10);
            if (*endptr != '\0') {
                usage ();
                exit (1);
            }
            break;
        case 's':
            sBits = strtoul (optarg, &endptr, 10);
            if (*endptr != '\0') {
                usage ();
                exit (1);
            }
            break;
        case 'l':
            alg = PH;
            break;
        case 'r':
            alg = RHO;
            break;
        case ':':
        case '?':
            usage ();
            exit (EXIT_FAILURE);
        }
    }

    gmp_randinit_default (rstate);
    seedRandState (rstate);

    // If there are 4 arguments left after processing switches,
    // treat them as a discrete log instance.
    if (optind == argc - 4) {
 
        mpz_set_str (alpha, argv[optind], 10);
        mpz_set_str (p, argv[optind+1], 10);
        mpz_set_str (n, argv[optind+2], 10);
        mpz_set_str (beta, argv[optind+3], 10);

        if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
            returnValue = EXIT_FAILURE;
        }
 
    }

    // If test was requested with -t, run the algorithm on some specific
    // discrete log instances.
    if (test) {

        mpz_set_ui (alpha, 2);
        mpz_set_ui (p, 383);
        mpz_set_ui (n, 191);
        mpz_set_ui (beta, 228);

        if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
            returnValue = EXIT_FAILURE;
        }

        // this instance should force pollard rho to run more than once.
        mpz_set_ui (alpha, 859401326);
        mpz_set_ui (p, 2124867817);
        mpz_set_ui (n, 37691);
        mpz_set_ui (beta, 944531857);

        if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
            returnValue = EXIT_FAILURE;
        }
 
        mpz_set_ui (alpha, 20);
        mpz_set_ui (p, 251);
        mpz_set_ui (n, 5);
        mpz_set_ui (beta, 113);

        if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
            returnValue = EXIT_FAILURE;
        }

        if (alg == PH) {
            // n = 250 = 2 * 5^3
            /*
            PrimePower factors[2];
            fi_n.factors = factors;
            fi_n.nFactors = 2;
            mpz_init_set_ui (factors[0].prime, 2);
            factors[0].power = 1;
            mpz_init_set_ui (factors[1].prime, 5);
            factors[1].power = 3;
            mpz_init_set_ui (fi_n.value, 250);
            */

            mpz_set_ui (alpha, 121812136);
            mpz_set_ui (p, 196530371);
            mpz_set_ui (n, 4045);
            mpz_set_ui (beta, 68442556);

            if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
                returnValue = EXIT_FAILURE;
            }

            mpz_set_ui (alpha, 71);
            mpz_set_ui (p, 251);
            mpz_set_ui (n, 250);
            mpz_set_ui (beta, 210);

            if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
                returnValue = EXIT_FAILURE;
            }

            mpz_set_ui (alpha, 400489563u);
            mpz_set_ui (p, 2426640901u);
            mpz_set_ui (n, 52242u);
            mpz_set_ui (beta, 778085329u);

            if (!test_alg (result, alpha, p, n, beta, rstate, verbose, alg)) {
                returnValue = EXIT_FAILURE;
            }

        }

    }
    
    // if a count was specified with -cN, then run the algorithm on N random discrete log instances.
    if (count > 0) {
        DECLARE_PH_LOCALS
        INIT_PH_LOCALS(p)

        for (int i=0; i < count; i++) {
            if (!test_random_order (result, alpha, p, n, beta,
                                    y, nBits, pBits, sBits, rstate, verbose, alg, LIST_PH_LOCALS)) {
                returnValue = EXIT_FAILURE;
                if (!verbose)
                    printf (" 0");
            } else if (!verbose) {
                printf (" +");
            }
        }

        if (!verbose) { printf ("\n"); }
        
        CLEAR_PH_LOCALS
    }

    mpz_clear (result);
    mpz_clear (alpha);
    mpz_clear (p);
    mpz_clear (n);
    mpz_clear (beta);
    mpz_clear (y);
    gmp_randclear (rstate);

    return returnValue;
}

/*
FactoredInteger * factorTrialDivision (const mpz_t x) {
    mpz_t y, q, r, p;
    mpz_init_set (y, x);
    mpz_init (q); mpz_init (r);
    mpz_init_set_ui (p, 3);

    FactoredInteger *f = (FactoredInteger *) malloc (sizeof (*f));
    mpz_init_set (f->value, x);

    if (mpz_probab_prime_p (x, 10)) {

        f->factors = (PrimePower *) malloc (sizeof (*factors));
        mpz_init_set (f->factors[0].prime, x);
        f->factors[0].power = 1;
        f->nFactors = 1;

    } else {
        int nFactors = 1;
        int factorsSize = 10;
        int power;

        PrimePower *factors = (PrimePower *) malloc (factorsSize * sizeof (*factors));

        // check for powers of two
        power = 0;
        while (mpz_tstbit (y, power) == 0) {
            power++;
        }

        if (power > 0) {
            mpz_fdiv_q_2exp (y, y, power);

            mpz_init_set_ui (factors[0].prime, 2);
            factors[0].power = power;
        }

        do {
            mpz_fdiv_qr (q, r, y, p);
            mpz_set (y, q);
        } while (mpz_cmp_ui (y, 1) > 0);

    }
    mpz_clear (y);
    mpz_clear (q); mpz_clear (r); mpz_clear (p);

    return f;
}
*/
